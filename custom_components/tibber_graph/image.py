"""Image platform for Tibber Graph component."""
from __future__ import annotations

import logging
from pathlib import Path

from homeassistant.components.image import ImageEntity
from homeassistant.config_entries import ConfigEntry
from homeassistant.core import HomeAssistant, callback
from homeassistant.helpers.entity_platform import AddEntitiesCallback
from homeassistant.helpers import entity_registry as er
from homeassistant.helpers.entity import DeviceInfo
from homeassistant.util import dt as dt_util

from .const import DOMAIN, CONF_ENTITY_NAME, CONF_PRICE_ENTITY_ID
from .helpers import get_graph_file_path, get_unique_id

_LOGGER = logging.getLogger(__name__)


async def async_setup_entry(
    hass: HomeAssistant,
    entry: ConfigEntry,
    async_add_entities: AddEntitiesCallback,
) -> None:
    """Set up Tibber Graph image from a config entry."""
    entities = []

    # Get entity name from config entry data
    entity_name = entry.data.get(CONF_ENTITY_NAME, entry.title or "Tibber Graph")

    # Get price entity ID from config entry data
    price_entity_id = entry.data.get(CONF_PRICE_ENTITY_ID)

    if price_entity_id:
        # Use entity as price source
        _LOGGER.info("Setting up Tibber Graph image using entity: %s", price_entity_id)
        entities.append(TibberGraphImage(hass, entry, entity_name))
    else:
        # Use Tibber integration as price source
        if "tibber" not in hass.config.components or "tibber" not in hass.data:
            _LOGGER.error("Tibber integration not configured and no price entity provided")
            return

        # Create one image entity per Tibber home
        for home in hass.data["tibber"].get_homes(only_active=True):
            entities.append(TibberGraphImage(hass, entry, entity_name))

    _LOGGER.info("Setting up %d Tibber Graph image(s)", len(entities))
    async_add_entities(entities)


class TibberGraphImage(ImageEntity):
    """Image entity that displays the Tibber price graph image.

    This entity is a lightweight alternative to the Camera entity.
    It simply displays the PNG file that is generated by the Camera entity.
    All image updates (including auto-refresh) are triggered by the Camera entity
    via the tibber_graph_updated event, so no file monitoring is needed.
    """

    _attr_has_entity_name = False

    def __init__(self, hass: HomeAssistant, entry: ConfigEntry, entity_name: str):
        """Initialize the Tibber Graph image."""
        super().__init__(hass)

        self._entry = entry
        self._entity_name = entity_name

        # Always prefix entity name with "Tibber Graph"
        self._attr_name = f"Tibber Graph {entity_name}"

        # Use the same PNG file as the camera entity (via helper function)
        self._file_path = Path(get_graph_file_path(hass, entity_name))

        # Generate unique ID using helper function
        self._attr_unique_id = get_unique_id("image", entity_name, entry.entry_id)

        # Get camera unique ID to match events
        self._camera_unique_id = get_unique_id("camera", entity_name, entry.entry_id)
        self._camera_entity_id = None

        # Set up device info to group with camera and sensor
        self._attr_device_info = DeviceInfo(
            identifiers={(DOMAIN, f"{entry.entry_id}")},
            name=f"Tibber Graph {entity_name}",
            manufacturer="stefanes",
            model="Tibber Graph",
            entry_type=None,
        )

    async def async_added_to_hass(self) -> None:
        """Run when entity is added to hass."""
        await super().async_added_to_hass()

        # Find the camera entity ID
        entity_registry = er.async_get(self.hass)

        # Search for camera entity with matching unique_id
        for entity_entry in er.async_entries_for_config_entry(entity_registry, self._entry.entry_id):
            if entity_entry.unique_id == self._camera_unique_id:
                self._camera_entity_id = entity_entry.entity_id
                _LOGGER.debug("Found camera entity: %s for image %s", self._camera_entity_id, self.entity_id)
                break

        if not self._camera_entity_id:
            _LOGGER.warning("Could not find camera entity with unique_id %s for image %s",
                          self._camera_unique_id, self.entity_id)

        # Load the initial image if it exists
        if self._file_path.exists():
            await self._async_load_image()
            _LOGGER.debug("Loaded initial image for %s from %s", self._attr_name, self._file_path)
        else:
            _LOGGER.debug("No initial image found for %s at %s", self._attr_name, self._file_path)

        # Listen for camera updates to reload the image
        # This covers all update scenarios:
        # - Manual render (action)
        # - Camera access
        # - Auto-refresh (periodic updates)
        self.async_on_remove(
            self.hass.bus.async_listen(
                "tibber_graph_updated",
                self._handle_camera_update,
            )
        )

    @callback
    def _handle_camera_update(self, event) -> None:
        """Handle camera update event to reload the image.

        This is triggered by the Camera entity whenever it updates the PNG file,
        including during auto-refresh, so no separate file monitoring is needed.
        """
        # Only reload if this is an update for our camera
        if event.data.get("entity_id") == self._camera_entity_id:
            if self._file_path.exists():
                self.hass.async_create_task(self._async_load_image())
                _LOGGER.debug("Reloaded image for %s after camera update (triggered by: %s)",
                             self._attr_name, event.data.get("triggered_by", "unknown"))

    async def _async_load_image(self) -> None:
        """Load the image from the file."""
        try:
            image_bytes = await self.hass.async_add_executor_job(
                self._file_path.read_bytes
            )
            self._attr_image_last_updated = dt_util.utcnow()
            self._cached_image = image_bytes
            self.async_write_ha_state()
        except Exception as err:
            _LOGGER.error("Failed to load image for %s: %s", self._attr_name, err)

    async def async_image(self) -> bytes | None:
        """Return bytes of image."""
        if not hasattr(self, "_cached_image"):
            if self._file_path.exists():
                await self._async_load_image()
            else:
                return None
        return getattr(self, "_cached_image", None)
